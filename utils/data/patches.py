import numpy as np
from utils import args 

def reconstruct_distances(distances:np.array, args:args):
    """
        Reconstruct distance vector to original dimensions when using patches

        Parameters
        ----------
        distances (np.array): Vector of per neighbour distances
        args (Namespace): cmd_args 

        Returns
        -------
        dists (np.array): reconstructed patches if necessary

    """

    dists = np.mean(distances, axis = tuple(range(1,distances.ndim)))
    dists = np.array([[d]*args.patch_size**2 for d in dists]).reshape(len(dists), 
                                                                args.patch_size, 
                                                                args.patch_size)

    dists_recon = reconstruct(np.expand_dims(dists,axis=-1),args)
    return dists_recon

def reconstruct(patches:np.array, args:args):
    """
        Reconstructs the original training/testing images from the patches 
        NOTE: does not work on patches where stride!=patch_size or when data has been central cropped
        
        Parameters
        ----------
        patches (np.array) array of patches generated by get_patches() 
        args (Namespace): the argumenets from cmd_args

        Returns
        -------
        np.array, (optional) np.array

    """
    t = patches.transpose(0,2,1,3)
    n_patches = 256//args.patch_size

    recon = np.empty([patches.shape[0]//n_patches**2, 
        args.patch_size*n_patches,
        args.patch_size*n_patches,patches.shape[-1]])

    start, counter, indx, b  = 0, 0, 0, []

    for i in range(n_patches, patches.shape[0]+1, n_patches):
        b.append(np.reshape(np.stack(t[start:i,...],axis=0),(n_patches*args.patch_size,args.patch_size, patches.shape[-1])))
        start = i
        counter +=1
        if counter == n_patches:
            recon[indx,...] = np.hstack(b)
            indx+=1
            counter, b = 0, []

    return recon.transpose(0,2,1,3)
